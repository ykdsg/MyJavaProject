## 背景
OrderAppService 属于应用层的应用服务，它就不应该包含具体的业务逻辑。倘若我们将发送邮件和异步消息发送视为“横切关注点”，那么在应用服务中调用它们是合乎情理的；然而，通过 Order 组装 Notification 与 OrderConfirmed 的职责，却应该放在领域层，因为基于订单去生成邮件内容以及发布事件包含了业务逻辑与规则。问题出现！由于这两个对象是由领域层生成的对象，我们该如何将领域层生成的对象传递给处于它之上的应用层对象？

## 方案1-demo1
将组装通知邮件与订单确认事件的职责封装到领域层的相关类中，然后在应用层调用这些类的方法，如此可以减少应用层的领域逻辑。</br>

> 相当于应用层负责事件的发送，如果在比较复杂的场景，应用层可能需要负责很多事件的发送，对应用层心智负担较重。


## 方案2-demo2
第二种方案则将“上层对下层的调用”改为“下层对上层的通知”，即前面讲解层之间协作时所谓“自底向上”的通信问题，这就需要在领域层为订单业务定义 OrderEventPublisher 接口。通过它在领域层发布事件，这个事件即所谓“领域事件（Domain Event）”。</br>

> 这里的前提是：发送邮件与异步发送通知属于应用逻辑的一部分。感觉这种方式 ***最复杂***，应用层维护事件发送逻辑的真实逻辑（handler），并注册到领域层，领域层负责事件的触发。

## 方案3-demo3
重新分配 NotificationService 与 EventBus，将这两个抽象接口放到单独的一个名为 interfaces 的包中，这个 interfaces 包既不属于应用层，又不属于领域层。通过这样的职责分配后，业务逻辑发生了转移，发送邮件与异步发送通知的调用不再放到应用服务 OrderAppService 中，而是封装到了 PlaceOrderService 领域服务。</br>

> 这里的前提是：发送邮件与异步发送通知属于业务逻辑的一部分。相对来说这种方式更自然一些。
